import asyncio
import logging
from typing import List, Optional

from .engine import AbstractANXEngineAPI
from .models.public_address import PublicAddress

logger = logging.getLogger(__name__)


class PublicEngineAddress(AbstractANXEngineAPI):
    def get(self, address_identifier: str) -> PublicAddress:
        """
        Get an address by identifier from the Public Engine API
        Args:
            address_identifier: the addresses' identifier
        Returns:
            A PublicAddress object
        """
        return asyncio.run(self._async_get(address_identifier))

    def search(
        self, search: str = None, prefix_identifier: str = None
    ) -> Optional[List[PublicAddress]]:
        """
        Search for addresses via the Public Engine API
        Args:
            search: a string to query for (optional)
            prefix_identifier: limit search to a prefix (optional)
        Returns:
            A list of addresses matching the query
        """
        return asyncio.run(self._async_search(search, prefix_identifier))

    async def _async_search(
        self, search: str = None, prefix_identifier: str = None
    ) -> Optional[List[PublicAddress]]:
        params = {}
        if search:
            params["search"] = search
        if prefix_identifier:
            params["prefix"] = prefix_identifier

        data = await self.engine._api_search(
            "/ipam/v1/address/filtered.json", params=params
        )
        if not data:
            return None

        addresses = await self._async_abstract_search(data)
        return addresses

    async def _async_get(self, address_identifier: str) -> PublicAddress:
        data = (
            await self.engine._api_get(f"/ipam/v1/address.json/{address_identifier}")
        )[0]

        data["address"] = data["name"]
        data["role"] = data["role_text"]
        if data["vlan"]:
            data["vlan"] = await self.engine.vlan._async_get(data["vlan"])
        data["prefix"] = await self.engine.prefix._async_get(data["prefix"])
        return PublicAddress.from_dict(data)

    def create(
        self,
        prefix_identifier: str,
        address: str,
        description_customer: str = "",
        role: str = "Default",
        organization_identifier: str = "",
    ) -> dict:
        """
        Create a new Address via the Public Engine API
        Args:
            prefix_identifier: The identifier of the prefix within which the address shall be created
            address: The IP address to create (without netmask)
            description_customer: customer facing description (optional)
            role: The role of the address, one of 'Default' or 'Reserved' (default: Default)
            organization_identifier: customer of a reseller (optional)
        Returns:
            A dict representing the created address
        Raises:
            A ValueError if role is not one of the valid choices
        """
        if role not in [None, "Default", "Reserved"]:
            raise ValueError(f"{role} is not a valid role choice.")

        post_data = {
            "name": address,
            "prefix": prefix_identifier,
            "description_customer": description_customer,
            "role": role,
            "organization": organization_identifier,
        }
        data = self.engine._api_post(f"/ipam/v1/address.json", post_data=post_data)
        logger.info(
            f"Created address {data['name']} on public API: {data['identifier']}"
        )
        return data

    def update(
        self,
        address_identifier: str,
        description_customer: str,
        role: str,
        organization_identifier: str = None,
    ) -> dict:
        """
        Update attributes of an address
        This endpoint does NOT support partial updates (ENGSUP-5437) - you have to set both attributes.
        Args:
            address_identifier: the identifier of the address to update
            description_customer: customer facing description
            role: The role of the address, one of 'Default' or 'Reserved'
            organization_identifier: customer of a reseller (optional)
        Returns:
            A dict containing details of the updated address
        Raises:
            A ValueError if role is not one of the valid choices
        """
        if role not in [None, "Default", "Reserved"]:
            raise ValueError(f"{role} is not a valid role choice.")

        put_data = {"description_customer": description_customer, "role": role}
        if organization_identifier is not None:
            put_data["organization"] = organization_identifier

        data = self.engine._api_put(
            f"/ipam/v1/address.json/{address_identifier}",
            put_data=put_data,
        )
        logger.info(f"Updated address {address_identifier} via public API")
        return data

    def delete(self, address_identifier: str) -> dict:
        """
        Request the deletion of an Address via the Public Engine API
        Args:
            address_identifier: The addresses' identifier
        Returns:
            A dict with some information about the deletion request
        """
        data = self.engine._api_delete(f"/ipam/v1/address.json/{address_identifier}")
        logger.info(
            f"Requested deletion of address with identifier {address_identifier} via public API"
        )
        return data
