import asyncio
import datetime
import ipaddress
import logging

from .engine import AbstractANXEngineAPI
from .models.dns import DNSRecord, DNSZone

logger = logging.getLogger(__name__)


class EngineDNS(AbstractANXEngineAPI):
    def get_zone(self, name: str) -> DNSZone:
        """
        Get a DNS zone with all existing records
        Args:
            name: the zone name
        Returns:
            A DNSZone objeect including all records
        """
        return asyncio.run(self._async_get_zone(name))

    def _parse_zone(self, data: dict) -> DNSZone:
        """
        Parse a DNS zone from JSON response
        Args:
            data: zone as dict
        Returns:
            DNSZone object of the provided data
        Raises:
            NotImplementedError when the API returns more than one revision
        """
        if not data["revisions"][0]["identifier"] == data["current_revision"]:
            raise NotImplementedError
            # the API currently only returns one revision, if this changes we need to implement it

        records = []
        for record in data["revisions"][0]["records"]:
            records.append(DNSRecord(**record))

        dns_servers = []
        for server in data["dns_servers"]:
            dns_servers.append(server["server"])

        created = datetime.datetime.fromisoformat(
            data["created_at"].replace("Z", "+00:00")
        )
        updated = datetime.datetime.fromisoformat(
            data["updated_at"].replace("Z", "+00:00")
        )
        published = datetime.datetime.fromisoformat(
            data["published_at"].replace("Z", "+00:00")
        )

        zone = DNSZone(
            name=data["name"],
            master_ns=data["master_ns"],
            master=data["master"],
            editable=data["is_editable"],
            admin_email=data["admin_email"],
            created=created,
            updated=updated,
            published=published,
            current_revision=data["current_revision"],
            expire=data["expire"],
            refresh=data["refresh"],
            retry=data["retry"],
            ttl=data["ttl"],
            records=records,
            dns_servers=dns_servers,
        )

        return zone

    async def _async_get_zone(self, name: str) -> DNSZone:
        data = (await self.engine._api_get(f"/clouddns/v1/zone.json/{name}"))[0]
        zone = self._parse_zone(data)
        return zone

    def create_record(
        self,
        zone: DNSZone,
        name: str,
        rtype: str,
        rdata: str,
        region: str = None,
        ttl: int = None,
    ) -> DNSZone:
        """
        Create a DNS record for a given zone
        Args:
            zone: A DNSZone object under which you want to create the record
            name: name of the record you want to create relative to the zone
            rtype: DNS record type, see https://en.wikipedia.org/wiki/List_of_DNS_record_types
            rdata: DNS record data
            region: identifier of a region (optional)
            ttl: Time To Live, if None the DNSZones TTL will be used
        Returns:
            The updated DNS zone including
        Raises:
            ValueError when the zone is not editable
        """

        if not zone.editable:
            logger.error("Failed to create record, zone is not editable")
            raise ValueError

        post_data = {
            "name": name,
            "type": rtype,
            "rdata": rdata,
        }

        if region:
            post_data["region"] = region
        if ttl:
            post_data["ttl"] = ttl

        data = self.engine._api_post(
            f"/clouddns/v1/zone.json/{zone.name}/records", post_data=post_data
        )

        return self._parse_zone(data)
