import asyncio
import logging
from typing import List, Optional, Type, Union
from urllib.parse import urlencode

from anx_pyengine.engine import AbstractANXEngineAPI, ANXEngine, PublicANXEngine
from anx_pyengine.models.generic_service_resource import GenericServiceResource

logger = logging.getLogger(__name__)


class EngineGenericServiceResource(AbstractANXEngineAPI):
    def __init__(
        self,
        engine_instance: Union[ANXEngine, PublicANXEngine],
        model: Type[GenericServiceResource],
    ):
        self.model = model
        super().__init__(engine_instance)

    @property
    def path(self):
        return self.model.get_path()

    def get(self, identifier: str) -> GenericServiceResource:
        """
        Get a GenericServiceResource by its identifier.
        Args:
            identifier: The resources's identifier
        Returns:
            A GenericServiceResource object
        """
        return asyncio.run(self._async_get(identifier))

    async def _async_get(self, identifier: str) -> GenericServiceResource:
        data = await self.engine._api_get(f"{self.path}/{identifier}")
        return self.model.from_dict(data[0], infer_missing=True)

    def search(
        self, search: str = None, filters: dict = None
    ) -> List[GenericServiceResource]:
        """
        Search for GenericServiceResources.
        Omitting all parameters will list all resources.
        Args:
            search: A keyword to search for in the resources' attributes
            filters: A dict where the results will have the given values in the attributes specified by the keys
        Returns:
            A list of GenericServiceResource objects
        """
        return asyncio.run(self._async_search(search, filters))

    async def _async_search(
        self, search: str = None, filters: dict = None
    ) -> List[GenericServiceResource]:
        params = {}
        if search:
            params["search"] = search
        if filters:
            params["filters"] = urlencode(filters)
        data = await self.engine._api_get(self.path, params=params)
        return [await self._async_get(item["identifier"]) for item in data]

    def create(self, resource: GenericServiceResource) -> GenericServiceResource:
        """
        Create a new GenericServiceResource.
        Args:
            resource: The resource to create, modeled as the corresponding python object
        Returns:
            A GenericServiceResource object from the values the Engine responded with
        """
        post_data = resource.to_dict()
        data = self.engine._api_post(self.path, post_data=post_data)
        logger.info(f"Created resource at {self.path}: {data['identifier']}")
        return self.model.from_dict(data, infer_missing=True)

    def update(self, resource: GenericServiceResource) -> GenericServiceResource:
        """
        Update GenericServiceResource.
        Args:
            resource: The resource to update, modeled as the corresponding python object
        Returns:
            A GenericServiceResource object from the values the Engine responded with
        """
        post_data = resource.to_dict()
        data = self.engine._api_put(
            f"{self.path}/{resource.identifier}", put_data=post_data
        )
        logger.info(f"Updated resource at {self.path}: {data['identifier']}")
        return self.model.from_dict(data, infer_missing=True)

    def delete(self, identifier: str) -> bool:
        """
        Deletes a GenericServiceResource.
        Args:
            identifier: The identifier of the resource which will be deleted
        Returns:
            The boolean the Engine responded with
        """
        data = self.engine._api_delete(f"{self.path}/{identifier}")
        logger.info(f"Requested deletion at {self.path} with identifier {identifier}")
        return data

    def fire_rule(
        self,
        identifier: str,
        rule_identifier: str,
        input_parameters: Optional[list] = None,
    ) -> dict:
        """
        Fire a Generic Automation rule for an object.
        Args:
            identifier: The object's identifier
            rule_identifier: The rule's identifier
            input_parameters: An array of additional, dynamic input parameters for the rule
        """
        post_data = {}
        if input_parameters is not None:
            post_data["input_parameters"] = input_parameters
        data = self.engine._api_post(
            f"{self.path}/{identifier}/rule/{rule_identifier}",
            post_data=post_data,
        )
        logger.info(
            f"Fired rule {rule_identifier} at {self.path} for resource {identifier}"
        )
        return data

    def fire_rule_by_name(
        self,
        identifier: str,
        rule_name: str,
        input_parameters: Optional[list] = None,
    ) -> dict:
        """
        Fire a Generic Automation rule for an object based on the rule's name.
        Only the first occurrence of a rule with that name will be fired.
        Args:
            identifier: The object's identifier
            rule_name: The rule's name
            input_parameters: An array of additional, dynamic input parameters for the rule
        """
        generic_service_object = self.get(identifier)

        for rule in generic_service_object.automation_rules:
            if rule.name == rule_name:
                return self.fire_rule(
                    identifier,
                    rule.identifier,
                    input_parameters,
                )
