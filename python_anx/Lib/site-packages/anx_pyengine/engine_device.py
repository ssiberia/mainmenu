import asyncio
import io
import logging
import sys

from .engine import AbstractANXEngineAPI
from .models.device import Device
from .utils import Colors

logger = logging.getLogger(__name__)


class EngineDevice(AbstractANXEngineAPI):
    def search(self, search: str, force: bool = False) -> list:
        """
        Search a device by string
        Args:
            search: A string to search for
            force: force the search eventough many results will be returned (default: False)
        Returns:
            A list of devices matching the search pattern
        """
        return asyncio.run(self._async_search(search, force))

    def get(self, identifier: str) -> Device:
        """
        Get a Device object by identifier
        Args:
            identifier: the devices identifier
        Returns:
            A Device object of a device is found
        """
        return asyncio.run(self._async_get(identifier))

    async def _async_search(self, search: str, force: bool = False) -> list:
        params = {"search": search}
        data = await self.engine._api_get(
            endpoint="/config-management/v1/device.json", params=params
        )
        if len(data) > 50 and not force:
            logger.error(
                "This query returned over 50 results, and will produce quite a lot of API Calls. If you're sure you want to continue pass force=True to your function call"
            )
            return None

        devices = await self._async_abstract_search(data)
        return devices

    async def _async_get(self, identifier: str) -> Device:
        data = (
            await self.engine._api_get(
                f"/config-management/v1/device.json/{identifier}"
            )
        )[0]

        location = await self.engine.location._async_get(data["location"]["code"])
        # for whatever reason the engine returns -1 or None
        if data["api_management_interface"] not in (-1, None):
            mgmt_interface = await self.engine.deviceinterface._async_get(
                data["api_management_interface"]["identifier"]
            )
            mgmt_interface_id = data["api_management_interface"]["identifier"]
        else:
            mgmt_interface = None
            mgmt_interface_id = None

        try:
            device = Device(
                identifier=data["identifier"],
                hostname=data["hostname"],
                hostname_full=data["hostname_full"],
                location=location,
                version=data["version"],
                status=data["status_text"],
                vendor=data["device_type"]["vendor"],
                model=data["device_type"]["model"],
                function=data["device_type"]["function"],
                mgmt_interface_id=mgmt_interface_id,
                mgmt_interface=mgmt_interface,
            )

            return device
        except TypeError:
            logger.error(f"Error parsing data for device {identifier}.")

    def deploy(
        self,
        device: Device,
        output: bool = False,
        output_io: io.TextIOWrapper = sys.stdout,
    ) -> list:
        """
        Deploy the passed device (without committing the config!)
        Args:
            device: the Device object to deploy
            output: if the output should be printed to output_io (default: False)
            output_io: the output to write to (default: sys.stdout)
        Returns:
            The comparison output
        """
        post_data = {"compare": True}
        data = self.engine._api_post(
            f"/config-management/v1/device.json/{device.identifier}/deploy",
            post_data=post_data,
        )

        logger.info(f"Deployed to {device.hostname}: {data['messages'][0]}")
        response = data["data"]["response"].split("\n")
        response = list(filter(None, response))  # remove empty elements from list

        if output:
            for line in response:
                if line.startswith("+"):
                    print(f"{Colors.GREEN}{line}{Colors.ENDCOLOR}", file=output_io)
                elif line.startswith("-"):
                    print(f"{Colors.RED}{line}{Colors.ENDCOLOR}", file=output_io)
                else:
                    print(line, file=output_io)

        return response

    def rollback(self, device: Device) -> dict:
        """
        Rollback the passed device to its previous configuration
        Args:
            device: The Device object to roll back
        Returns:
            A dict containing the data retruned by the Device, the devices messages and a status
        """

        data = self.engine._api_post(
            f"/config-management/v1/device.json/{device.identifier}/rollback",
        )

        logger.info(f"Performed rollback on {device.hostname}: {data['messages'][0]}")

        return data

    def commit_check(self, device: Device) -> dict:
        """
        Perform a commit check on the passed device
        Args:
            device: The Device object to perform commit check on
        Returns:
            A dict containing the data retruned by the Device, the devices messages and a status
        """

        data = self.engine._api_post(
            f"/config-management/v1/device.json/{device.identifier}/commit-check",
        )

        logger.info(
            f"Performed commit check on {device.hostname}: {data['messages'][0]}"
        )

        return data

    def commit_confirmed(self, device: Device, timeout: int = 10) -> dict:
        """
        Perform a commit confirmed on the passed device
        Args:
            device: The Device object to perform commit check on
            timeout: timeout in minutes for the rollback (default = 10)
        Returns:
            A dict containing the data retruned by the Device, the devices messages and a status
        """

        post_data = {"rollback": timeout}
        data = self.engine._api_post(
            f"/config-management/v1/device.json/{device.identifier}/commit-confirm",
            post_data=post_data,
        )

        logger.info(
            f"Performed commit confirmed {timeout} on {device.hostname}: {data['messages'][0]}"
        )

        return data

    def commit(self, device: Device) -> dict:
        """
        Perform a commit on the passed device
        Args:
            device: The Device object to perform commit check on
        Returns:
            A dict containing the data retruned by the Device, the devices messages and a status
        """

        data = self.engine._api_post(
            f"/config-management/v1/device.json/{device.identifier}/commit",
        )

        logger.info(f"Performed commit on {device.hostname}: {data['messages'][0]}")

        return data
