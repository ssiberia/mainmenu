import asyncio
import logging

from .engine import AbstractANXEngineAPI
from .models.device import Device
from .models.policy import Policy

logger = logging.getLogger(__name__)


class EnginePolicy(AbstractANXEngineAPI):
    def get(self, identifier) -> Policy:
        """
        Get a policy object by its identifier
        Args:
            identifier: the policies identifier
        Returns:
            A Policy object
        """
        return asyncio.run(self._async_get(identifier))

    def search(self, search: str, force: bool = False) -> list:
        """
        Search a device policy by string
        Args:
            search: A string to search for
            force: force the search eventough many results will be returned (default: False)
        Returns:
            A list of policies matching the search pattern
        """
        return asyncio.run(self._async_search(search, force))

    async def _async_search(self, search: str, force: bool = False) -> list:
        params = {"search": search}
        data = await self.engine._api_get(
            "/config-management/v1/policy.json", params=params
        )
        if len(data) > 50 and not force:
            logger.error(
                "This query returned over 50 results, and will produce quite a lot of API Calls. If you're sure you want to continue pass force=True to your function call"
            )
            return None

        policies = await self._async_abstract_search(data)
        return policies

    async def _async_get(self, identifier: str) -> Policy:
        data = (
            await self.engine._api_get(
                f"/config-management/v1/policy.json/{identifier}"
            )
        )[0]

        assigned_devices = []
        assigned_devices = await asyncio.gather(
            *(
                self.engine.device._async_get(device["identifier"])
                for device in data["assigned_devices"]
            )
        )

        assigned_groups = []
        assigned_groups = await asyncio.gather(
            *(self._async_get(group["identifier"]) for group in data["assigned_groups"])
        )

        policy = Policy(
            identifier=identifier,
            name=data["name"],
            is_group=data["is_group"],
            pattern=data["pattern"].split("\n") if data["pattern"] else None,
            assigned=data["assigned"],
            assigned_devices=assigned_devices,
            assigned_groups=assigned_groups,
            peering_name=data["peering_name"],
            session_name=data["session_name"],
            is_scnd_policy=data["is_scnd_policy"],
        )

        return policy

    def _manage_policy_association(
        self,
        policy: Policy,
        device: Device = None,
        group: Policy = None,
        unassign: bool = False,
    ) -> Policy:
        """
        Assign OR Unassign a policy to/from either a device or a policy group.
        The attributes device and group are mutually exclusive, but one is required.
        Args:
            policy: the policy that shall be (un)assigned
            device: a device to (un)assign the policy to/from.
            group: a policy group to (un)assign the policy to/from.
            unassign: False: assing policy, True: unassign policy
        Raises:
            AttributeError: if neither group nor device are defined
            AttributeError: if group and device are defined
            TypeError: if group.is_policy == False
        Returns:
            The policy object reflecting the changes
        """
        if not device and not group:
            raise AttributeError("Either a device or a group must be defined")
        if device and group:
            raise AttributeError("device and group are mutually exclusive")
        if group and not group.is_group:
            raise TypeError("The policy passed is not a group (is_group must be true)")

        if device:
            post_data = {"device": device.identifier}
        if group:
            post_data = {"policy_group": group.identifier}

        if unassign:
            data = self.engine._api_post(
                f"/config-management/v1/policy.json/{policy.identifier}/unassign",
                post_data=post_data,
            )
            logger.info(f"Unassigned {policy.name} from {post_data}")
        else:
            data = self.engine._api_post(
                f"/config-management/v1/policy.json/{policy.identifier}/assign",
                post_data=post_data,
            )
            logger.info(f"Assigned {policy.name} to {post_data}")

        policy = self.get(data["identifier"])

        return policy

    def assign(
        self,
        policy: Policy,
        device: Device = None,
        group: Policy = None,
    ) -> Policy:
        """
        Assign a policy to either a device or a policy group.
        The attributes device and group are mutually exclusive, but one is required.
        Args:
            policy: the policy that shall be assigned
            device: a device to assign the policy to.
            group: a policy group to assign the policy to.
        Returns:
            The policy object reflecting the changes
        """

        policy = self._manage_policy_association(policy, device, group)

        return policy

    def unassign(
        self,
        policy: Policy,
        device: Device = None,
        group: Policy = None,
    ) -> Policy:
        """
        Unassign a policy from either a device or a policy group.
        The attributes device and group are mutually exclusive, but one is required.
        Args:
            policy: the policy that shall be unassigned
            device: a device to unassign the policy from.
            group: a policy group to unassign the policy from.
        Returns:
            The policy object reflecting the changes
        """

        policy = self._manage_policy_association(policy, device, group, unassign=True)

        return policy
