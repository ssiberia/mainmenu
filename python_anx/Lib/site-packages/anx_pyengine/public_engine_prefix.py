import asyncio
import ipaddress
import logging
from typing import Optional

from .engine import AbstractANXEngineAPI
from .models.location import Location
from .models.public_prefix import PublicPrefix
from .models.public_vlan import PublicVLAN

logger = logging.getLogger(__name__)


class PublicEnginePrefix(AbstractANXEngineAPI):
    def get(self, prefix_identifier: str) -> PublicPrefix:
        """
        Get a prefix by identifier from the Public Engine API
        Args:
            prefix_identifier: the prefix's identifier
        Returns:
            A PublicPrefix object
        """
        return asyncio.run(self._async_get(prefix_identifier))

    def search(self, search: str, organization_identifier: str = None) -> list:
        """
        Search for a prefix via the Public Engine API
        Args:
            search: a string to query for
            organization_identifier: limit search to to an organization (optional)
        Returns:
            A list of prefixes matching the query
        """
        return asyncio.run(self._async_search(search, organization_identifier))

    async def _async_search(
        self, search: str, organization_identifier: str = None
    ) -> Optional[list]:
        params = {"search": search}
        # aiohttp does not accept NoneType as parameter
        if organization_identifier:
            params["organization_identifier"] = organization_identifier

        data = await self.engine._api_search(
            "/ipam/v1/prefix/filtered.json", params=params
        )
        if not data:
            return None

        prefixes = await self._async_abstract_search(data)
        return prefixes

    async def _async_get(self, prefix_identifier: str) -> PublicPrefix:
        data = (
            await self.engine._api_get(f"/ipam/v1/prefix.json/{prefix_identifier}")
        )[0]

        prefix_ipaddr = ipaddress.ip_network(data["name"])

        locations = await asyncio.gather(
            *(
                self.engine.location._async_get(location["code"])
                for location in data["locations"]
            )
        )

        vlans = await asyncio.gather(
            *(self.engine.vlan._async_get(vlan["identifier"]) for vlan in data["vlans"])
        )

        data["prefix"] = prefix_ipaddr
        data["locations"] = locations
        data["vlans"] = vlans
        data["prefix_type"] = data["type"]
        return PublicPrefix.from_dict(data)

    def create(
        self,
        location: Location,
        version: int,
        prefix_type: int,
        netmask: int,
        vlan: PublicVLAN,
        router_redundancy: bool = False,
        vm_provisioning: bool = True,
        description_customer: str = "",
        organization_identifier: str = "",
    ) -> dict:
        """
        Create a new Prefix via the Public Engine API
        Args:
            location: a location object, the prefix's location
            version: the IP version (4 or 6)
            prefix_type: 0 for public prefix, 1 for private prefix
            netmask: the CIDR prefix length (e.g. 29)
            vlan: PublicVLAN object to create the prefix in
            router_redundancy: if VRRP should be enabled in the prefix
                               (requires: minimum /29 IPv4 or /64 IPv6, default=False)
            vm_provisioning: if VM provisioning should be enabled (default=True)
            description_customer: customer facing description (optional)
            organization_identifier: customer of a reseller (optional)
        Returns:
            A dict representing the created prefix
        Raises:
            TypeError when the IP version is neither 4 nor 6
            ValueError when the prefix length doesn't allow for VRRP
        """
        if version not in [4, 6]:
            raise TypeError("Invalid IP protocol specified, must be 4 or 6")
        if version == 4 and router_redundancy and netmask > 29:
            raise ValueError("Max prefix length for VRRP on IPv4 is /29")
        if version == 6 and router_redundancy and netmask > 64:
            raise ValueError("Max prefix length for VRRP on IPv6 is /64")
        post_data = {
            "location": location.identifier,
            "version": version,
            "type": prefix_type,
            "netmask": netmask,
            "vlan": vlan.identifier,
            "router_redundancy": router_redundancy,
            "vm_provisioning": vm_provisioning,
            "organization": organization_identifier,
            "description_customer": description_customer,
        }
        data = self.engine._api_post(f"/ipam/v1/prefix.json", post_data=post_data)
        logger.info(
            f"Created prefix {data['name']} on public API: {data['identifier']}"
        )
        return data

    def delete(self, prefix_identifier: str) -> dict:
        """
        Request the deletion of a Prefix via the Public Engine API
        Args:
            prefix_identifier: The prefixes identifier
        Returns:
            A dict with some information about the deletion request
        """
        data = self.engine._api_delete(f"/ipam/v1/prefix.json/{prefix_identifier}")
        logger.info(
            f"Requested deletion of prefix with identifier {prefix_identifier} via public API"
        )
        return data
