import asyncio
import ipaddress
import logging

from .engine import AbstractANXEngineAPI
from .models.aggregate import Aggregate
from .models.location import Location
from .models.organization import Organization
from .models.prefix import Prefix
from .models.vlan import VLAN

logger = logging.getLogger(__name__)


class EnginePrefix(AbstractANXEngineAPI):
    def get(self, prefix_identifier: str) -> Prefix:
        """
        Get prefix by identifier
        Args:
            prefix_identifier: the prefixes identifier
        Returns:
            A prefix object
        """
        return asyncio.run(self._async_get(prefix_identifier))

    def search(
        self, search: str, customer: Organization = None, force: bool = False
    ) -> list:
        """
        Search for a prefix
        Args:
            search: a string to query for
            customer: limit search to a customer (optional)
        Returns:
            A list of prefixes matching the query
            None if the search yielded > 50 results and ANXEngine.full_search = False
        """
        return asyncio.run(self._async_search(search, customer, force))

    async def _async_search(
        self, search: str, customer: Organization = None, force: bool = False
    ) -> list:
        params = {"search": search}
        # aiohttp does not accept NoneType as parameter
        if customer:
            params["customer"] = customer.identifier

        data = await self.engine._api_search(
            "/ipam/v1/prefix/filtered.json", params=params
        )
        if not data:
            return None

        prefixes = await self._async_abstract_search(data)

        return prefixes

    async def _async_get(self, prefix_identifier: str) -> Prefix:
        data = (
            await self.engine._api_get(f"/ipam/v1/prefix.json/{prefix_identifier}")
        )[0]

        prefix_ipaddr = ipaddress.ip_network(data["name"])

        locations = []
        locations = await asyncio.gather(
            *(
                self.engine.location._async_get(location["code"])
                for location in data["locations"]
            )
        )

        pfx = Prefix(
            prefix=prefix_ipaddr,
            identifier=data["identifier"],
            locations=locations,
            customer_identifier=data["customer_identifier"],
            aggregate_identifier=data["aggregate"]["identifier"],
            rir_identifier=data["rir"]["identifier"],
            rir_name=data["rir"]["name"],
        )

        return pfx

    def create(
        self,
        location: Location,
        version: int,
        private: bool,
        netmask: int,
        ticket: str,
        aggregate: Aggregate,
        description: str,
        create_gateway: int,
        customer: Organization,
        default_vlan: VLAN = None,
        managed_status: int = 10,
        parent_prefix: Prefix = None,
        descritption_customer: str = None,
        reseller: Organization = None,
    ) -> dict:
        """
        Create a new Prefix within an aggregate (not SCND!)
        Args:
            location: A location object where you want to create the prefix a
            version: IPv4(4) or IPv6(6)
            private: True if the prefix should not be publically routable
            netmask: The desired netmask for the prefix
            ticket: ATS ticket number
            aggregate: The Aggreagte object under which the prefix should be created
            description: Description for the prefix
            create_gateway: 1 if gateway shoudl be first IP, 2 if gateway should be last IP, 0 for no gateway
            customer: Organizaition object of the customer
            default_vlan: VLAN object where the prefix should be created in (optional)
            managed_status: integer of the status, default: None  4 = managed, 7 = semi-managed, 10 = unmanaged, 16 = unspecified
            parent_prefix: Prefix that should be the parent of this object (Optional)
            description_customer: Customer description of the prefix (Optional)
            reseller: Organization object of the reseller (Optional)
        Raises:
            TypeError: when the protocol is neither IPv4 or IPv6
            TypeError: when create_gateway is not 0,1 or 2
        """
        if version not in [4, 6]:
            raise TypeError("Invalid IP protocol specified, must be 4 or 6")
        if create_gateway not in range(2):
            raise TypeError("create_gateway must be 0(no), 1(firt IP) or 2(last IP)")

        post_data = {
            "location": location.identifier,
            "version": version,
            "private": private,
            "netmask": netmask,
            "ticket": ticket,
            "aggregate": aggregate.identifier,
            "description": description,
            "create_default_gateway": create_gateway,
            "managed_status": managed_status,
        }
        if default_vlan and create_gateway != 0:
            post_data["default_vlan"] = default_vlan.identifier
        if parent_prefix:
            post_data["parent_prefix"] = parent_prefix.identifier
        if descritption_customer:
            post_data["description_customer "] = descritption_customer
        if reseller:
            post_data["reseller_identifier"] = reseller.identifier
        data = self.engine._api_post(f"/ipam/v1/prefix.json", post_data=post_data)
        logger.info(f"created prefix {data['name']}: {data['identifier']}")
        return data

    def create_scnd(
        self,
        location: Location,
        version: int,
        private: bool,
        netmask: int,
        vlan: VLAN,
        ticket: str,
        description: str,
        router_redundancy: bool,
        vm_provisioning: bool,
        customer: Organization,
        managed_status: int = None,
        description_customer: str = "",
    ) -> dict:
        """
        Create a new SCND Prefix
        Args:
            location: a location object of the prefixes location
            version: the IP version (4 or 6)
            private: True if private prefix False if public
            netmask: the CIDR prefix length (e.g. 29)
            vlan: vlan object to create the prefix in
            ticket: the ATS ticket number
            description: prefix description
            router_redundancy: if VRRP should be enabled vor the interface (requires: minimum /29 IPv4 or /64 IPv6)
            vm_provisioning: if VM provisioning should be enabled
            customer: Organization object of the customer
            managed_status: integer of the status, default: None  4 = managed, 7 = semi-managed, 10 = unmanaged, 16 = unspecified
            description_customer: customer facing desctiption (optional)
        Returns:
            A dict representing the created prefix
        Raises:
            TypeError when the IP version is neither 4 or 6
            ValueError when the prefix length doesn't allow for VRRP
        """
        if version not in [4, 6]:
            raise TypeError("Invalid IP protocol specified, must be 4 or 6")
        if version == 4 and router_redundancy and netmask > 29:
            raise ValueError("Max prefix length for VRRP on IPv4 is /29")
        if version == 6 and router_redundancy and netmask > 64:
            raise ValueError("Max prefix length for VRRP on IPv6 is /64")
        post_data = {
            "location": location.identifier,
            "version": version,
            "type": 1 if private == True else 0,
            "netmask": netmask,
            "vlan": vlan.identifier,
            "ticket": ticket,
            "description": description,
            "router_redundancy": router_redundancy,
            "vm_provisioning": vm_provisioning,
            "customer": customer.identifier,
            "managed_status": "" if None else managed_status,
            "description_customer": description_customer,
        }
        data = self.engine._api_post(f"/ipam/v1/prefix/scnd.json", post_data=post_data)
        logger.info(f"created prefix {data['name']}: {data['identifier']}")
        return data
