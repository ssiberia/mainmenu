import asyncio
import ipaddress
import logging
from typing import List

from .engine import AbstractANXEngineAPI
from .models.location import Location
from .models.organization import Organization
from .models.vm import VM, DiskType, VMInfo, VMTemplate

logger = logging.getLogger(__name__)


class EngineVM(AbstractANXEngineAPI):
    def get_info(self, vm_identifier: str) -> VMInfo:
        """
        Get information about a VM as a VMInfo object, based on its identifier
        Args:
            vm_identifier: The VM's identifier
        Returns:
            A VMInfo object containing all the information about the VM
        """
        return asyncio.run(self._async_get_info(vm_identifier))

    async def _async_get_info(self, vm_identifier: str) -> VMInfo:
        data = (
            await self.engine._api_get(f"/vsphere/v1/info.json/{vm_identifier}/info")
        )[0]

        # Replace scattered and incomplete location information with Location object
        location = await self.engine.location._async_get_by_identifier(
            data["location_identifier"]
        )
        data["location"] = location
        data.pop("location_identifier")
        data.pop("location_code")
        data.pop("location_country")
        data.pop("location_name")

        # Replace string representation of IP addresses with proper objects
        for network in data["network"]:
            for ips_version in ["ips_v4", "ips_v6"]:
                ips_str = network.get(ips_version, [])
                ips_obj = []
                for ip in ips_str:
                    ips_obj.append(ipaddress.ip_address(ip))
                network[ips_version] = ips_obj

        return VMInfo.from_dict(data)

    async def _sanitize_location(self, vm: VM) -> VM:
        # Replace scattered and incomplete location information with Location object
        location = await self.engine.location._async_get(vm["location_code"])
        vm["location"] = location
        vm.pop("location_code")
        vm.pop("location_country")
        vm.pop("location_name")
        return vm

    def search_byname(self, name: str) -> List[VM]:
        """
        Search for a VM by name
        Args:
            name: the VM's name
        Returns:
            A list of VM objects or empty list if nothing is found.
        """
        return asyncio.run(self._async_search_byname(name))

    async def _async_search_byname(self, name: str) -> List[VM]:
        params = {"name": name}
        data = await self.engine._api_get(
            "/vsphere/v1/search/by_name.json", params=params
        )
        for vm in data:
            await self._sanitize_location(vm)
        return [VM.from_dict(vm) for vm in data]

    def search_bytags(self, tags: str) -> List[VM]:
        """
        Search for VMs by tag
        Args:
            tags: comma separated list of tags
        Returns:
            A list of VM objects or empty list if nothing is found.
        """
        return asyncio.run(self._async_search_bytags(tags))

    async def _async_search_bytags(self, tags: str) -> List[VM]:
        params = {"tags": tags}
        data = await self.engine._api_get(
            "/vsphere/v1/search/by_tags.json", params=params
        )

        for vm in data:
            await self._sanitize_location(vm)
        return [VM.from_dict(vm) for vm in data]

    def create(
        self,
        location: Location,
        template: VMTemplate,
        hostname: str,
        memory_mb: int,
        cpus: int,
        disk_gb: int,
        ssh_key: str,
        networks: list,
        organization: Organization = None,
        disk_type: DiskType = None,
        cpu_performance_type: str = "standard",
        start_script: str = "",
    ) -> dict:
        """
        Create a VM by Template
        Params:
            location: the location object where you want to create the VM at
            template: the template object you want to create the VM from
            hostname: the hostname to use
            memory_mb: Amount of memory in MB
            cpus: Amount of CPU cores
            disk_gb: The disk size in Gigabyts
            ssh_key: a ssh key for the root user
            network: a list of dicts of network interfaces, format:
                 [
                    {"nic_type":"vmxnet3",
                     "vlan": Vlan.identifier,
                     "ips":["10.0.0.1", "10.0.0.2", ...]},
                     ...
                    ]
            organization: The organziation this VM belongs to (Reseller only feature, optional)
            disk_type: A DiskType object to use (Optional).
                       By default pyengine will not POST this parameter if it is not supplied,
                       and the Engine will default to a type based on the datacenter, i.e. location.
            cpu_performance_type: choice of "best-effort", "standard"(default), "enterprise", "performance"
            start_script: a base64 encoded start script (Optional)
        Returns:
            A dict containing a Progress identifier and other data about the creation process
        Raises:
            AttirbuteError if the cpu_performance_type is invalid
        """
        if cpu_performance_type not in [
            "best-effort",
            "standard",
            "enterprise",
            "performance",
        ]:
            raise AttributeError

        post_data = {
            "hostname": hostname,
            "memory_mb": memory_mb,
            "cpus": cpus,
            "disk_gb": disk_gb,
            "ssh": ssh_key,
            "network": networks,
            "cpu_performance_type": cpu_performance_type,
            "script": start_script,
        }

        if organization is not None:
            post_data["organization"] = organization.identifier
        if disk_type is not None:
            post_data["disk_type"] = disk_type.id

        data = self.engine._api_post(
            f"/vsphere/v1/provisioning/vm.json/{location.identifier}/{template.template_type}/{template.id}",
            post_data=post_data,
        )
        logger.info(f"Created VM {hostname}, id: {data['identifier']}")
        return data

    def delete(self, vm_identifier: str, delayed: bool = True) -> dict:
        """
        Schedule the deletion of a VM
        Args:
            vm_identifier: The VM's identifier
            delayed: Whether to delay deletion by one day or execute it immediately (Default: True)
        Returns:
            A dict with some information about the deletion schedule
        """
        data = self.engine._api_delete(
            f"/vsphere/v1/provisioning/vm.json/{vm_identifier}",
            params={"delayed": delayed},
        )
        logger.info(f"Scheduled deletion of VM with identifier {vm_identifier}")
        return data
