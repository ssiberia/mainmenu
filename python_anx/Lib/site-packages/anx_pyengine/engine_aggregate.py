import asyncio
import ipaddress

from .engine import AbstractANXEngineAPI
from .models.aggregate import Aggregate
from .models.organization import Organization


class EngineAggregate(AbstractANXEngineAPI):
    def search(self, search: str, customer: Organization = None, force: bool = False):
        """
        Search for a Aggregate
        Args:
            search: a string to query for
            customer: limit search to a customer (optional)
            force: Run search even when more than 50 results will be returned
        Returns:
            A list of Prefix Objects matching the query
            None if the search yielded > 50 results and ANXEngine.full_search = False
        """
        return asyncio.run(self._async_search(search, customer, force))

    def get(self, aggregate_identifier: str) -> Aggregate:
        """
        Get aggregate by identifier
        Args:
            aggregate_identifier: the aggregates identifier
        Returns:
            Aggregate object
        """
        return asyncio.run(self._async_get(aggregate_identifier))

    async def _async_search(
        self, search: str, customer: Organization = None, force: bool = False
    ) -> list:
        params = {"search": search}
        # aiohttp does not accept NoneType as parameter
        if customer:
            params.extend({"customer": customer.identifier})

        data = await self.engine._api_get(
            "/ipam/v1/aggregate/filtered.json", params=params
        )
        if not data or (len(data) > 50 and not force):
            return None

        aggregates = await self._async_abstract_search(data)
        return aggregates

    async def _async_get(self, aggregate_identifier: str) -> Aggregate:
        data = (
            await self.engine._api_get(
                f"/ipam/v1/aggregate.json/{aggregate_identifier}"
            )
        )[0]

        prefix_ipaddr = ipaddress.ip_network(data["name"])

        locations = []
        locations = await asyncio.gather(
            *(
                self.engine.location._async_get(location["code"])
                for location in data["locations"]
            )
        )

        aggregate = Aggregate(
            prefix=prefix_ipaddr,
            identifier=data["identifier"],
            locations=locations,
            description=data["description"],
            customer_identifier=data["customer_identifier"],
            allocation_identifier=data["allocation"]["identifier"],
            rir_identifier=data["rir"]["identifier"],
            rir_name=data["rir"]["name"],
            vrf_identifier=data["vrf"]["identifier"],
            vrf_name=data["vrf"]["name"],
        )

        return aggregate
