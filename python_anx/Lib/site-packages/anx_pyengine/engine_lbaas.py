import logging

from anx_pyengine.engine import AbstractANXEngineAPI
from anx_pyengine.engine_generic_service_resource import EngineGenericServiceResource
from anx_pyengine.models.lbaas import (
    Backend,
    BackendServer,
    Frontend,
    FrontendBind,
    LoadBalancer,
)

logger = logging.getLogger(__name__)


class EngineLBaaS(AbstractANXEngineAPI):
    """
    Wrappers for the Anexia Load Balancer as a Service Module
    As of August 2021 it is available as a live beta version, as such its API methods and responses are subject
    to change and not all constraints are reflected here.
    """

    def __init__(self, engine_instance):
        super().__init__(engine_instance)
        self.load_balancer = EngineGenericServiceResource(
            self.engine,
            LoadBalancer,
        )

        self.backend = EngineGenericServiceResource(
            self.engine,
            Backend,
        )

        self.backend_server = EngineGenericServiceResource(
            self.engine,
            BackendServer,
        )

        self.frontend = EngineGenericServiceResource(
            self.engine,
            Frontend,
        )

        self.frontend_bind = EngineGenericServiceResource(
            self.engine,
            FrontendBind,
        )

    def create_load_balancer(self, name: str, ip_address: str, state: int = 3):
        """
        Create a new Load Balancer.
        Args:
            name: The name of the load balancer
            ip_address: The IP address of the machine which is to be configured as a load balancer
            state: The state of the created load balancer, one of 0 - OK, 1 - Error, 3 - Created (Default: 3)
        Returns:
            A dict with some information about the created load balancer, including its identifier.
        """
        post_data = {"name": name, "ip_address": ip_address, "state": state}
        data = self.engine._api_post(
            f"/LBaaS/v1/loadbalancer.json", post_data=post_data
        )
        logger.info(f"Created loadbalancer {data['name']}: {data['identifier']}")
        return data

    def create_frontend(
        self,
        name: str,
        load_balancer_identifier: str,
        default_backend_identifier: str,
        mode: str = "http",
        client_timeout: str = 300000,
        enable: bool = True,
        state: int = 4,
    ):
        """
        Create a new Frontend.
        Args:
            name: The name of the frontend
            load_balancer_identifier: The identifier of the load balancer on which this frontend shall be created
            default_backend_identifier: The identifier of this frontend's default backend
            mode: The mode for this frontend, one of "http" or "tcp" (Default="http")
            client_timeout: The timeout on this frontend (Default=300000)
            enable: Whether this frontend shall be enabled upon creation (Default=True)
            state: The state of the created frontend,
                   one of 0 - Updating, 1 - Updated, 2 - Deployment Error, 3 - Deployed, 4 - Newly Created
                   (Default: 4)
        Returns:
            A dict with some information about the created frontend, including its identifier.
        """
        post_data = {
            "name": name,
            "load_balancer": load_balancer_identifier,
            "default_backend": default_backend_identifier,
            "mode": mode,
            "client_timeout": client_timeout,
            "enable": enable,
            "state": state,
        }

        data = self.engine._api_post(f"/LBaaS/v1/frontend.json", post_data=post_data)
        logger.info(f"Created frontend {data['name']}: {data['identifier']}")
        return data

    def create_frontend_bind(
        self,
        name: str,
        frontend_identifier: str,
        port: int = 80,
        ssl: bool = False,
        state: int = 4,
    ):
        """
        Create a new Frontend Bind.
        Args:
            name: The name of the frontend bind
            frontend_identifier: The identifier of the frontend for this bind
            port: The port to bind and listen on (Default=80)
            ssl: Whether SSL/TLS should be enabled for this bind (Default=False)
            state: The state of the created frontend bind,
                   one of 0 - Updating, 1 - Updated, 2 - Deployment Error, 3 - Deployed, 4 - Newly Created
                   (Default: 4)
        Returns:
            A dict with some information about the created frontend bind, including its identifier.
        """
        post_data = {
            "name": name,
            "frontend": frontend_identifier,
            "port": port,
            "ssl": ssl,
            "state": state,
        }

        data = self.engine._api_post(f"/LBaaS/v1/bind.json", post_data=post_data)
        logger.info(f"Created bind {data['name']}: {data['identifier']}")
        return data

    def create_backend(
        self,
        name: str,
        load_balancer_identifier: str,
        health_check: str = '"httpchk": { "method": "GET", "uri": "/" }',
        mode: str = "http",
        server_timeout: int = 300000,
        enable: bool = True,
        state: int = 4,
    ):
        """
        Create a new Backend.
        Args:
            name: The name of the backend
            load_balancer_identifier: The identifier of the load balancer on which this backend shall be configured
            health_check: The health check to run, e.g. '"adv_check": "tcp-check"'
                          (Default='"httpchk": {"method": "GET","uri": "/"}')
            mode: The mode for this backend, one of "http" or "tcp" (Default="http")
            server_timeout: The timeout on this backend (Default=300000)
            enable: Whether this backend shall be enabled upon creation (Default=True)
            state: The state of the created backend,
                   one of 0 - Updating, 1 - Updated, 2 - Deployment Error, 3 - Deployed, 4 - Newly Created
                   (Default: 4)
        Returns:
            A dict with some information about the created backend, including its identifier.
        """
        post_data = {
            "name": name,
            "load_balancer": load_balancer_identifier,
            "health_check": health_check,
            "mode": mode,
            "server_timeout": server_timeout,
            "enable": enable,
            "state": state,
        }

        data = self.engine._api_post(f"/LBaaS/v1/backend.json", post_data=post_data)
        logger.info(f"Created backend {data['name']}: {data['identifier']}")
        return data

    def create_backend_server(
        self,
        name: str,
        backend_identifier: str,
        host: str,
        port: int = 80,
        check: bool = True,
        state: int = 4,
    ):
        """
        Create a new Backend Server.
        Args:
            name: The name of the backend server
            backend_identifier: The identifier of the backend this server is a part of
            host: The host which is this backend server. Can be an IP address or a resolvable hostname.
            port: On which port the host is listening
            check: Whether the backend's health check shall be enabled for this backend server
            state: The state of the created backend server,
                   one of 0 - Updating, 1 - Updated, 2 - Deployment Error, 3 - Deployed, 4 - Newly Created
                   (Default: 4)
        Returns:
            A dict with some information about the created backend server, including its identifier.
        """
        post_data = {
            "name": name,
            "backend": backend_identifier,
            "ip": host,
            "port": port,
            "state": state,
        }
        if check is True:
            post_data["check"] = "enabled"
        elif check is False:
            post_data["check"] = "disabled"

        data = self.engine._api_post(f"/LBaaS/v1/server.json", post_data=post_data)
        logger.info(f"Created backend server {data['name']}: {data['identifier']}")
        return data

    def delete_load_balancer(self, identifier: str):
        """
        Deletes a Load Balancer.
        Args:
            identifier: The identifier of the Load Balancer which will be deleted
        Returns:
            A dict with some information about the deletion request.
        """
        data = self.engine._api_delete(f"/LBaaS/v1/loadbalancer.json/{identifier}")
        logging.info(
            f"Requested deletion of Load Balancer with identifier {identifier}"
        )
        return data

    def delete_frontend(self, identifier: str):
        """
        Deletes a Frontend.
        Args:
            identifier: The identifier of the Frontend which will be deleted
        Returns:
            A dict with some information about the deletion request.
        """
        data = self.engine._api_delete(f"/LBaaS/v1/frontend.json/{identifier}")
        logging.info(f"Requested deletion of Frontend with identifier {identifier}")
        return data

    def delete_frontend_bind(self, identifier: str):
        """
        Deletes a Frontend Bind.
        Args:
            identifier: The identifier of the Frontend Bind which will be deleted
        Returns:
            A dict with some information about the deletion request.
        """
        data = self.engine._api_delete(f"/LBaaS/v1/bind.json/{identifier}")
        logging.info(
            f"Requested deletion of Frontend Bind with identifier {identifier}"
        )
        return data

    def delete_backend_switching_rule(self, identifier: str):
        """
        Deletes a Backend Switching Rule.
        Args:
            identifier: The identifier of the Backend Switching Rule which will be deleted
        Returns:
            A dict with some information about the deletion request.
        """
        data = self.engine._api_delete(
            f"/LBaaS/v1/backendswitchingrule.json/{identifier}"
        )
        logging.info(
            f"Requested deletion of Backend Switching Rule with identifier {identifier}"
        )
        return data

    def delete_backend(self, identifier: str):
        """
        Deletes a Backend.
        Args:
            identifier: The identifier of the Backend which will be deleted
        Returns:
            A dict with some information about the deletion request.
        """
        data = self.engine._api_delete(f"/LBaaS/v1/backend.json/{identifier}")
        logging.info(f"Requested deletion of Backend with identifier {identifier}")
        return data

    def delete_map(self, identifier: str):
        """
        Deletes a Map.
        Args:
            identifier: The identifier of the Map which will be deleted
        Returns:
            A dict with some information about the deletion request.
        """
        data = self.engine._api_delete(f"/LBaaS/v1/map.json/{identifier}")
        logging.info(f"Requested deletion of Map with identifier {identifier}")
        return data

    def delete_backend_server(self, identifier: str):
        """
        Deletes a Backend Server.
        Args:
            identifier: The identifier of the Backend Server which will be deleted
        Returns:
            A dict with some information about the deletion request.
        """
        data = self.engine._api_delete(f"/LBaaS/v1/server.json/{identifier}")
        logging.info(
            f"Requested deletion of Backend Server with identifier {identifier}"
        )
        return data

    def delete_acl(self, identifier: str):
        """
        Deletes an ACL.
        Args:
            identifier: The identifier of the ACL which will be deleted
        Returns:
            A dict with some information about the deletion request.
        """
        data = self.engine._api_delete(f"/LBaaS/v1/acl.json/{identifier}")
        logging.info(f"Requested deletion of ACL with identifier {identifier}")
        return data

    def delete_rule(self, identifier: str):
        """
        Deletes a Rule.
        Args:
            identifier: The identifier of the Rule which will be deleted
        Returns:
            A dict with some information about the deletion request.
        """
        data = self.engine._api_delete(f"/LBaaS/v1/rule.json/{identifier}")
        logging.info(f"Requested deletion of Rule with identifier {identifier}")
        return data
